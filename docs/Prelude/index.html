<!DOCTYPE HTML>
<html><head><link rel="stylesheet" type="text/css" href="../bootstrap.min.css"><link rel="stylesheet" type="text/css" href="../style.css"><title>Prelude</title></head><body><div class="navbar navbar-default"><div class="container"><div class="navbar-header"><a class="navbar-brand">Core Libraries</a></div><ul class="nav navbar-nav"><li><a href="../index.html">Contents</a></li><li><a href="../index/index.html">Index</a></li></ul></div></div><div class="container" id="content"><h1>Prelude</h1><a name="otherwise" href="#otherwise"><h2><code>otherwise</code></h2></a><p class="decl"><code><span class="ident">otherwise</span> <span class="syntax">::</span> <span class="ctor">Boolean</span></code></p><ul></ul><p>An alias for <code>true</code>, which can be useful in guard clauses:</p>
<pre class="purescript"><code>max x y | x &gt;= y = x
        | otherwise = y
</code></pre>
<a name="flip" href="#flip"><h2><code>flip</code></h2></a><p class="decl"><code><span class="ident">flip</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span> <span class="ident">c</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">c</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">c</span></code></p><ul></ul><p>Flips the order of the arguments to a function of two arguments.</p>
<pre class="purescript"><code>flip const 1 2 = const 2 1 = 2
</code></pre>
<a name="const" href="#const"><h2><code>const</code></h2></a><p class="decl"><code><span class="ident">const</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></p><ul></ul><p>Returns its first argument and ignores its second.</p>
<pre class="purescript"><code>const 1 &quot;hello&quot; = 1
</code></pre>
<a name="asTypeOf" href="#asTypeOf"><h2><code>asTypeOf</code></h2></a><p class="decl"><code><span class="ident">asTypeOf</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></p><ul></ul><p>This function returns its first argument, and can be used to assert type equalities.
This can be useful when types are otherwise ambiguous.</p>
<pre class="purescript"><code>main = print $ [] `asTypeOf` [0]
</code></pre>
<p>If instead, we had written <code>main = print []</code>, the type of the argument <code>[]</code> would have
been ambiguous, resulting in a compile-time error.</p>
<a name="Semigroupoid" href="#Semigroupoid"><h2><code>Semigroupoid</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Semigroupoid"><span class="ctor">Semigroupoid</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&lt;&lt;&lt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">b</span> <span class="ident">c</span> <span class="ident">d</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">a</span> <span class="ident">c</span> <span class="ident">d</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="ident">b</span> <span class="ident">c</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="ident">b</span> <span class="ident">d</span></code></li></ul><p>A <code>Semigroupoid</code> is similar to a <a href="#category"><code>Category</code></a> but does not require an identity
element <code>id</code>, just composable morphisms.</p>
<p><code>Semigroupoid</code>s should obey the following rule:</p>
<ul>
<li>Associativity: <code>p &lt;&lt;&lt; (q &lt;&lt;&lt; r) = (p &lt;&lt;&lt; q) &lt;&lt;&lt; r</code></li>
</ul>
<p>One example of a <code>Semigroupoid</code> is the function type constructor <code>(-&gt;)</code>, with <code>(&lt;&lt;&lt;)</code> defined
as function composition.</p>
<a name="semigroupoidArr" href="#semigroupoidArr"><h2><code>semigroupoidArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semigroupoidArr</span> <span class="syntax">::</span> <a href="#Semigroupoid"><span class="ctor">Semigroupoid</span></a> <span class="ctor">Function</span> <span class="keyword">where</span></code></p><ul></ul><a name="(&gt;&gt;&gt;)" href="#(&gt;&gt;&gt;)"><h2><code>(&gt;&gt;&gt;)</code></h2></a><p class="decl"><code><span class="ident">(&gt;&gt;&gt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span> <span class="ident">c</span> <span class="ident">d</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Semigroupoid"><span class="ctor">Semigroupoid</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="ident">b</span> <span class="ident">c</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="ident">c</span> <span class="ident">d</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="ident">b</span> <span class="ident">d</span></code></p><ul></ul><p>Forwards composition, or <code>(&lt;&lt;&lt;)</code> with its arguments reversed.</p>
<a name="Category" href="#Category"><h2><code>Category</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Semigroupoid"><span class="ctor">Semigroupoid</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#Category"><span class="ctor">Category</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">id</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">t</span><span class="syntax">.</span> <span class="ident">a</span> <span class="ident">t</span> <span class="ident">t</span></code></li></ul><p><code>Category</code>s consist of objects and composable morphisms between them, and as such are
<a href="#semigroupoid"><code>Semigroupoids</code></a>, but unlike <code>semigroupoids</code> must have an identity element.</p>
<p><code>Category</code>s should obey the following rules.</p>
<ul>
<li>Left Identity: <code>id &lt;&lt;&lt; p = p</code></li>
<li>Right Identity: <code>p &lt;&lt;&lt; id = p</code></li>
</ul>
<a name="categoryArr" href="#categoryArr"><h2><code>categoryArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">categoryArr</span> <span class="syntax">::</span> <a href="#Category"><span class="ctor">Category</span></a> <span class="ctor">Function</span> <span class="keyword">where</span></code></p><ul></ul><a name="($)" href="#($)"><h2><code>($)</code></h2></a><p class="decl"><code><span class="ident">($)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></p><ul></ul><p>Applies a function to its argument</p>
<pre class="purescript"><code>length $ groupBy productCategory $ filter isInStock products
</code></pre>
<p>is equivalent to</p>
<pre class="purescript"><code>length (groupBy productCategory (filter isInStock (products)))
</code></pre>
<p><code>($)</code> is different from <a href="#-2"><code>(#)</code></a> because it is right-infix instead of left, so
<code>a $ b $ c $ d x</code> = <code>a $ (b $ (c $ (d $ x)))</code> = <code>a (b (c (d x)))</code></p>
<a name="(#)" href="#(#)"><h2><code>(#)</code></h2></a><p class="decl"><code><span class="ident">(#)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></p><ul></ul><p>Applies a function to its argument</p>
<pre class="purescript"><code>products # groupBy productCategory # filter isInStock # length
</code></pre>
<p>is equivalent to</p>
<pre class="purescript"><code>length (groupBy productCategory (filter isInStock (products)))
</code></pre>
<p><code>(#)</code> is different from <a href="#-1"><code>($)</code></a> because it is left-infix instead of right, so
<code>x # a # b # c # d</code> = <code>(((x # a) # b) # c) # d</code> = <code>d (c (b (a x)))</code></p>
<a name="(:)" href="#(:)"><h2><code>(:)</code></h2></a><p class="decl"><code><span class="ident">(:)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span> <span class="syntax">-&gt;</span> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span></code></p><ul></ul><p>An infix alias for <code>cons</code>.</p>
<p>Note, the running time of this function is <code>O(n)</code>.</p>
<a name="cons" href="#cons"><h2><code>cons</code></h2></a><p class="decl"><code><span class="ident">cons</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span> <span class="syntax">-&gt;</span> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span></code></p><ul></ul><p>Attaches an element to the front of an array, creating a new array.</p>
<pre class="purescript"><code>cons 1 [2, 3, 4] = [1, 2, 3, 4]
</code></pre>
<p>Note, the running time of this function is <code>O(n)</code>.</p>
<a name="Show" href="#Show"><h2><code>Show</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Show"><span class="ctor">Show</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">show</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">String</span></code></li></ul><p>The <code>Show</code> type class represents those types which can be converted into a human-readable <code>String</code> representation.</p>
<p>While not required, it is recommended that for any expression <code>x</code>, the string <code>show x</code> be executable PureScript code
which evaluates to the same value as the expression <code>x</code>.</p>
<a name="showUnit" href="#showUnit"><h2><code>showUnit</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showUnit</span> <span class="syntax">::</span> <a href="#Show"><span class="ctor">Show</span></a> <a href="#Unit"><span class="ctor">Unit</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="showString" href="#showString"><h2><code>showString</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showString</span> <span class="syntax">::</span> <a href="#Show"><span class="ctor">Show</span></a> <span class="ctor">String</span> <span class="keyword">where</span></code></p><ul></ul><a name="showBoolean" href="#showBoolean"><h2><code>showBoolean</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showBoolean</span> <span class="syntax">::</span> <a href="#Show"><span class="ctor">Show</span></a> <span class="ctor">Boolean</span> <span class="keyword">where</span></code></p><ul></ul><a name="showNumber" href="#showNumber"><h2><code>showNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showNumber</span> <span class="syntax">::</span> <a href="#Show"><span class="ctor">Show</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="showArray" href="#showArray"><h2><code>showArray</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showArray</span> <span class="syntax">::</span> <span class="syntax">(</span><a href="#Show"><span class="ctor">Show</span></a> <span class="ident">a</span><span class="syntax">) =&gt;</span> <a href="#Show"><span class="ctor">Show</span></a> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span> <span class="keyword">where</span></code></p><ul></ul><a name="Functor" href="#Functor"><h2><code>Functor</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Functor"><span class="ctor">Functor</span></a> <span class="ident">f</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&lt;$&gt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">f</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <span class="ident">b</span></code></li></ul><p>A <code>Functor</code> is a type constructor which supports a mapping operation <code>(&lt;$&gt;)</code>.</p>
<p><code>(&lt;$&gt;)</code> can be used to turn functions <code>a -&gt; b</code> into functions <code>f a -&gt; f b</code> whose argument and return
types use the type constructor <code>f</code> to represent some computational context.</p>
<p><code>Functor</code> instances should satisfy the following laws:</p>
<ul>
<li>Identity: <code>(&lt;$&gt;) id = id</code></li>
<li>Composition: <code>(&lt;$&gt;) (f &lt;&lt;&lt; g) = (f &lt;$&gt;) &lt;&lt;&lt; (g &lt;$&gt;)</code></li>
</ul>
<a name="(&lt;#&gt;)" href="#(&lt;#&gt;)"><h2><code>(&lt;#&gt;)</code></h2></a><p class="decl"><code><span class="ident">(&lt;#&gt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">f</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Functor"><span class="ctor">Functor</span></a> <span class="ident">f</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">f</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <span class="ident">b</span></code></p><ul></ul><p><code>(&lt;#&gt;)</code> is <code>(&lt;$&gt;)</code> with its arguments reversed. For example:</p>
<pre class="purescript"><code>[1, 2, 3] &lt;#&gt; \n -&gt; n * n
</code></pre>
<a name="void" href="#void"><h2><code>void</code></h2></a><p class="decl"><code><span class="ident">void</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">f</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Functor"><span class="ctor">Functor</span></a> <span class="ident">f</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">f</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <a href="#Unit"><span class="ctor">Unit</span></a></code></p><ul></ul><p>The <code>void</code> function is used to ignore the type wrapped by a <a href="#functor"><code>Functor</code></a>, replacing it with <code>Unit</code> and
keeping only the type information provided by the type constructor itself.</p>
<p><code>void</code> is often useful when using <code>do</code> notation to change the return type of a monadic computation:</p>
<pre class="purescript"><code>main = forE 1 10 \n -&gt; void do
  print n
  print (n * n)
</code></pre>
<a name="Apply" href="#Apply"><h2><code>Apply</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Functor"><span class="ctor">Functor</span></a> <span class="ident">f</span><span class="syntax">) &lt;=</span> <a href="#Apply"><span class="ctor">Apply</span></a> <span class="ident">f</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&lt;*&gt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">f</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">f</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <span class="ident">b</span></code></li></ul><p>The <code>Apply</code> class provides the <code>(&lt;*&gt;)</code> which is used to apply a function to an argument under a type constructor.</p>
<p><code>Apply</code> can be used to lift functions of two or more arguments to work on values wrapped with the type constructor <code>f</code>.
It might also be understood in terms of the <code>lift2</code> function:</p>
<pre class="purescript"><code>lift2 :: forall f a b c. (Apply f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><code>(&lt;*&gt;)</code> is recovered from <code>lift2</code> as <code>lift2 ($)</code>. That is, <code>(&lt;*&gt;)</code> lifts the function application operator <code>($)</code> to arguments
wrapped with the type constructor <code>f</code>.</p>
<p><code>Apply</code> instances should satisfy the following law:</p>
<ul>
<li>Associative Composition: <code>(&lt;&lt;&lt;) &lt;$&gt; f &lt;*&gt; g &lt;*&gt; h = f &lt;*&gt; (g &lt;*&gt; h)</code></li>
</ul>
<p>Formally, <code>Apply</code> represents a strong lax semi-monoidal endofunctor.</p>
<a name="Applicative" href="#Applicative"><h2><code>Applicative</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Apply"><span class="ctor">Apply</span></a> <span class="ident">f</span><span class="syntax">) &lt;=</span> <a href="#Applicative"><span class="ctor">Applicative</span></a> <span class="ident">f</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">pure</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <span class="ident">a</span></code></li></ul><p>The <code>Applicative</code> type class extends the <a href="#apply"><code>Apply</code></a> type class with a <code>pure</code> function, which can be used to
create values of type <code>f a</code> from values of type <code>a</code>.</p>
<p>Where <a href="#apply"><code>Apply</code></a> provides the ability to lift functions of two or more arguments to functions whose arguments are wrapped using <code>f</code>,
and <a href="#functor"><code>Functor</code></a> provides the ability to lift functions of one argument, <code>pure</code> can be seen as the function which lifts functions of
<em>zero</em> arguments. That is, <code>Applicative</code> functors support a lifting operation for any number of function arguments.</p>
<p><code>Applicative</code> instances should satisfy the following laws:</p>
<ul>
<li>Identity: <code>(pure id) &lt;*&gt; v = v</code></li>
<li>Composition: <code>(pure &lt;&lt;&lt;) &lt;*&gt; f &lt;*&gt; g &lt;*&gt; h = f &lt;*&gt; (g &lt;*&gt; h)</code></li>
<li>Homomorphism: <code>(pure f) &lt;*&gt; (pure x) = pure (f x)</code></li>
<li>Interchange: <code>u &lt;*&gt; (pure y) = (pure ($ y)) &lt;*&gt; u</code></li>
</ul>
<a name="liftA1" href="#liftA1"><h2><code>liftA1</code></h2></a><p class="decl"><code><span class="ident">liftA1</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">f</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Applicative"><span class="ctor">Applicative</span></a> <span class="ident">f</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">f</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">f</span> <span class="ident">b</span></code></p><ul></ul><p><code>liftA1</code> provides a default implementation of <code>(&lt;$&gt;)</code> for any <a href="#applicative"><code>Applicative</code></a> functor,
without using <code>(&lt;$&gt;)</code> as provided by the <a href="#functor"><code>Functor</code></a>-<a href="#applicative"><code>Applicative</code></a> superclass relationship.</p>
<p><code>liftA1</code> can therefore be used to write <a href="#functor"><code>Functor</code></a> instances as follows:</p>
<pre class="purescript"><code>instance functorF :: Functor F where
  (&lt;$&gt;) = liftA1
</code></pre>
<a name="Bind" href="#Bind"><h2><code>Bind</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Apply"><span class="ctor">Apply</span></a> <span class="ident">m</span><span class="syntax">) &lt;=</span> <a href="#Bind"><span class="ctor">Bind</span></a> <span class="ident">m</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&gt;&gt;=)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><span class="ident">m</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">m</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">m</span> <span class="ident">b</span></code></li></ul><p>The <code>Bind</code> type class extends the <a href="#apply"><code>Apply</code></a> type class with a &quot;bind&quot; operation <code>(&gt;&gt;=)</code> which composes computations
in sequence, using the return value of one computation to determine the next computation.</p>
<p>The <code>&gt;&gt;=</code> operator can also be expressed using <code>do</code> notation, as follows:</p>
<pre class="purescript"><code>x &gt;&gt;= f = do y &lt;- x
             f y
</code></pre>
<p>where the function argument of <code>f</code> is given the name <code>y</code>.</p>
<p><code>Bind</code> instances should satisfy the following law:</p>
<ul>
<li>Associativity: <code>(x &gt;&gt;= f) &gt;&gt;= g = x &gt;&gt;= (\k =&gt; f k &gt;&gt;= g)</code></li>
</ul>
<p>Or, expressed using <code>do</code> notation:</p>
<ul>
<li>Associativity: <code>do { z &lt;- do { y &lt;- x ; f y } ; g z } = do { k &lt;- x ; do { y &lt;- f k ; g y } }</code></li>
</ul>
<p>Associativity tells us that we can regroup operations which use do-notation, so that we can unambiguously write, for example:</p>
<pre class="purescript"><code>do x &lt;- m1
   y &lt;- m2 x
   m3 x y
</code></pre>
<a name="Monad" href="#Monad"><h2><code>Monad</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Applicative"><span class="ctor">Applicative</span></a> <span class="ident">m</span><span class="syntax">,</span> <a href="#Bind"><span class="ctor">Bind</span></a> <span class="ident">m</span><span class="syntax">) &lt;=</span> <a href="#Monad"><span class="ctor">Monad</span></a> <span class="ident">m</span></code></p><ul></ul><p>The <code>Monad</code> type class combines the operations of the <code>Bind</code> and <code>Applicative</code> type classes. Therefore, <code>Monad</code> instances
represent type constructors which support sequential composition, and also lifting of functions of arbitrary arity.</p>
<p><code>Monad</code> instances should satisfy the following laws:</p>
<ul>
<li>Left Identity: <code>pure x &gt;&gt;= f = f x</code></li>
<li>Right Identity: <code>x &gt;&gt;= pure = x</code></li>
</ul>
<p>Or, expressed using <code>do</code> notation:</p>
<ul>
<li>Left Identity: <code>do { y &lt;- pure x ; f y } = f x</code></li>
<li>Right Identity: <code>do { y &lt;- x ; pure y } = x</code></li>
</ul>
<a name="return" href="#return"><h2><code>return</code></h2></a><p class="decl"><code><span class="ident">return</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">m</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Monad"><span class="ctor">Monad</span></a> <span class="ident">m</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">m</span> <span class="ident">a</span></code></p><ul></ul><p><code>return</code> is an alias for <code>pure</code>.</p>
<a name="liftM1" href="#liftM1"><h2><code>liftM1</code></h2></a><p class="decl"><code><span class="ident">liftM1</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">m</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Monad"><span class="ctor">Monad</span></a> <span class="ident">m</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">m</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">m</span> <span class="ident">b</span></code></p><ul></ul><p><code>liftM1</code> provides a default implementation of <code>(&lt;$&gt;)</code> for any <a href="#monad"><code>Monad</code></a>,
without using <code>(&lt;$&gt;)</code> as provided by the <a href="#functor"><code>Functor</code></a>-<a href="#monad"><code>Monad</code></a> superclass relationship.</p>
<p><code>liftM1</code> can therefore be used to write <a href="#functor"><code>Functor</code></a> instances as follows:</p>
<pre class="purescript"><code>instance functorF :: Functor F where
  (&lt;$&gt;) = liftM1
</code></pre>
<a name="ap" href="#ap"><h2><code>ap</code></h2></a><p class="decl"><code><span class="ident">ap</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">m</span> <span class="ident">a</span> <span class="ident">b</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Monad"><span class="ctor">Monad</span></a> <span class="ident">m</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="syntax">(</span><span class="ident">m</span> <span class="syntax">(</span><span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">b</span><span class="syntax">)</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="syntax">(</span><span class="ident">m</span> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">-&gt;</span> <span class="ident">m</span> <span class="ident">b</span></code></p><ul></ul><p><code>ap</code> provides a default implementation of <code>(&lt;*&gt;)</code> for any <a href="#monad"><code>Monad</code></a>,
without using <code>(&lt;*&gt;)</code> as provided by the <a href="#apply"><code>Apply</code></a>-<a href="#monad"><code>Monad</code></a> superclass relationship.</p>
<p><code>ap</code> can therefore be used to write <a href="#apply"><code>Apply</code></a> instances as follows:</p>
<pre class="purescript"><code>instance applyF :: Apply F where
  (&lt;*&gt;) = ap
</code></pre>
<a name="functorArr" href="#functorArr"><h2><code>functorArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">functorArr</span> <span class="syntax">::</span> <a href="#Functor"><span class="ctor">Functor</span></a> <span class="syntax">(</span><span class="ctor">Function</span> <span class="ident">r</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="applyArr" href="#applyArr"><h2><code>applyArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">applyArr</span> <span class="syntax">::</span> <a href="#Apply"><span class="ctor">Apply</span></a> <span class="syntax">(</span><span class="ctor">Function</span> <span class="ident">r</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="applicativeArr" href="#applicativeArr"><h2><code>applicativeArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">applicativeArr</span> <span class="syntax">::</span> <a href="#Applicative"><span class="ctor">Applicative</span></a> <span class="syntax">(</span><span class="ctor">Function</span> <span class="ident">r</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="bindArr" href="#bindArr"><h2><code>bindArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">bindArr</span> <span class="syntax">::</span> <a href="#Bind"><span class="ctor">Bind</span></a> <span class="syntax">(</span><span class="ctor">Function</span> <span class="ident">r</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="monadArr" href="#monadArr"><h2><code>monadArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">monadArr</span> <span class="syntax">::</span> <a href="#Monad"><span class="ctor">Monad</span></a> <span class="syntax">(</span><span class="ctor">Function</span> <span class="ident">r</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="Semiring" href="#Semiring"><h2><code>Semiring</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Semiring"><span class="ctor">Semiring</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(+)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li><li><code><span class="ident">zero</span> <span class="syntax">::</span> <span class="ident">a</span></code></li><li><code><span class="ident">(*)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li><li><code><span class="ident">one</span> <span class="syntax">::</span> <span class="ident">a</span></code></li></ul><p>Addition and multiplication, satisfying the following laws:</p>
<ul>
<li><code>a</code> is a commutative monoid under addition</li>
<li><code>a</code> is a monoid under multiplication</li>
<li>multiplication distributes over addition</li>
<li>multiplication by <code>zero</code> annihilates <code>a</code></li>
</ul>
<a name="ModuloSemiring" href="#ModuloSemiring"><h2><code>ModuloSemiring</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Semiring"><span class="ctor">Semiring</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#ModuloSemiring"><span class="ctor">ModuloSemiring</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(/)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li><li><code><span class="ident">mod</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li></ul><p>Addition, multiplication, modulo operation and division, satisfying:</p>
<ul>
<li><code>a / b * b + (a `mod` b) = a</code></li>
</ul>
<a name="Ring" href="#Ring"><h2><code>Ring</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Semiring"><span class="ctor">Semiring</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#Ring"><span class="ctor">Ring</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(-)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li></ul><p>Addition, multiplication, and subtraction.</p>
<p>Has the same laws as <code>Semiring</code> but additionally satisfying:</p>
<ul>
<li><code>a</code> is an abelian group under addition</li>
</ul>
<a name="negate" href="#negate"><h2><code>negate</code></h2></a><p class="decl"><code><span class="ident">negate</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Ring"><span class="ctor">Ring</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></p><ul></ul><a name="DivisionRing" href="#DivisionRing"><h2><code>DivisionRing</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Ring"><span class="ctor">Ring</span></a> <span class="ident">a</span><span class="syntax">,</span> <a href="#ModuloSemiring"><span class="ctor">ModuloSemiring</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#DivisionRing"><span class="ctor">DivisionRing</span></a> <span class="ident">a</span></code></p><ul></ul><p>Ring where every nonzero element has a multiplicative inverse so that:</p>
<ul>
<li><code>a `mod` b = zero</code></li>
</ul>
<a name="Num" href="#Num"><h2><code>Num</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#DivisionRing"><span class="ctor">DivisionRing</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#Num"><span class="ctor">Num</span></a> <span class="ident">a</span></code></p><ul></ul><p>A commutative field</p>
<a name="semiringNumber" href="#semiringNumber"><h2><code>semiringNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semiringNumber</span> <span class="syntax">::</span> <a href="#Semiring"><span class="ctor">Semiring</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="ringNumber" href="#ringNumber"><h2><code>ringNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ringNumber</span> <span class="syntax">::</span> <a href="#Ring"><span class="ctor">Ring</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="moduloSemiringNumber" href="#moduloSemiringNumber"><h2><code>moduloSemiringNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">moduloSemiringNumber</span> <span class="syntax">::</span> <a href="#ModuloSemiring"><span class="ctor">ModuloSemiring</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="divisionRingNumber" href="#divisionRingNumber"><h2><code>divisionRingNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">divisionRingNumber</span> <span class="syntax">::</span> <a href="#DivisionRing"><span class="ctor">DivisionRing</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="numNumber" href="#numNumber"><h2><code>numNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">numNumber</span> <span class="syntax">::</span> <a href="#Num"><span class="ctor">Num</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="Unit" href="#Unit"><h2><code>Unit</code></h2></a><p class="decl"><code><span class="keyword">newtype</span> <a href="#Unit"><span class="ctor">Unit</span></a></code></p><ul><li><code><a href="#Unit"><span class="ctor">Unit</span></a> <span class="syntax">{</span>  <span class="syntax">}</span></code></li></ul><p>The <code>Unit</code> type has a single inhabitant, called <code>unit</code>. It represents values with no computational content.</p>
<p><code>Unit</code> is often used, wrapped in a monadic type constructor, as the return type of a computation where only
the <em>effects</em> are important.</p>
<a name="unit" href="#unit"><h2><code>unit</code></h2></a><p class="decl"><code><span class="ident">unit</span> <span class="syntax">::</span> <a href="#Unit"><span class="ctor">Unit</span></a></code></p><ul></ul><p><code>unit</code> is the sole inhabitant of the <code>Unit</code> type.</p>
<a name="Eq" href="#Eq"><h2><code>Eq</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Eq"><span class="ctor">Eq</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(==)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></li><li><code><span class="ident">(/=)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></li></ul><p>The <code>Eq</code> type class represents types which support decidable equality.</p>
<p><code>Eq</code> instances should satisfy the following laws:</p>
<ul>
<li>Reflexivity: <code>x == x = true</code></li>
<li>Symmetry: <code>x == y = y == x</code></li>
<li>Transitivity: if <code>x == y</code> and <code>y == z</code> then <code>x == z</code></li>
<li>Negation: <code>x /= y = not (x == y)</code></li>
</ul>
<p><code>(/=)</code> may be implemented in terms of <code>(==)</code>, but it might give a performance improvement to implement it separately.</p>
<a name="eqUnit" href="#eqUnit"><h2><code>eqUnit</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqUnit</span> <span class="syntax">::</span> <a href="#Eq"><span class="ctor">Eq</span></a> <a href="#Unit"><span class="ctor">Unit</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="eqString" href="#eqString"><h2><code>eqString</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqString</span> <span class="syntax">::</span> <a href="#Eq"><span class="ctor">Eq</span></a> <span class="ctor">String</span> <span class="keyword">where</span></code></p><ul></ul><a name="eqNumber" href="#eqNumber"><h2><code>eqNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqNumber</span> <span class="syntax">::</span> <a href="#Eq"><span class="ctor">Eq</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="eqBoolean" href="#eqBoolean"><h2><code>eqBoolean</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqBoolean</span> <span class="syntax">::</span> <a href="#Eq"><span class="ctor">Eq</span></a> <span class="ctor">Boolean</span> <span class="keyword">where</span></code></p><ul></ul><a name="eqArray" href="#eqArray"><h2><code>eqArray</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqArray</span> <span class="syntax">::</span> <span class="syntax">(</span><a href="#Eq"><span class="ctor">Eq</span></a> <span class="ident">a</span><span class="syntax">) =&gt;</span> <a href="#Eq"><span class="ctor">Eq</span></a> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span> <span class="keyword">where</span></code></p><ul></ul><a name="Ordering" href="#Ordering"><h2><code>Ordering</code></h2></a><p class="decl"><code><span class="keyword">data</span> <a href="#Ordering"><span class="ctor">Ordering</span></a></code></p><ul><li><code><span class="ctor">LT</span></code></li><li><code><span class="ctor">GT</span></code></li><li><code><span class="ctor">EQ</span></code></li></ul><p>The <code>Ordering</code> data type represents the three possible outcomes of comparing two values:</p>
<p><code>LT</code> - The first value is <em>less than</em> the second.
<code>GT</code> - The first value is <em>greater than</em> the second.
<code>EQ</code> - The first value is <em>equal to</em> or <em>incomparable to</em> the second.</p>
<a name="eqOrdering" href="#eqOrdering"><h2><code>eqOrdering</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">eqOrdering</span> <span class="syntax">::</span> <a href="#Eq"><span class="ctor">Eq</span></a> <a href="#Ordering"><span class="ctor">Ordering</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="showOrdering" href="#showOrdering"><h2><code>showOrdering</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">showOrdering</span> <span class="syntax">::</span> <a href="#Show"><span class="ctor">Show</span></a> <a href="#Ordering"><span class="ctor">Ordering</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="semigroupOrdering" href="#semigroupOrdering"><h2><code>semigroupOrdering</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semigroupOrdering</span> <span class="syntax">::</span> <a href="#Semigroup"><span class="ctor">Semigroup</span></a> <a href="#Ordering"><span class="ctor">Ordering</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="Ord" href="#Ord"><h2><code>Ord</code></h2></a><p class="decl"><code><span class="keyword">class</span> <span class="syntax">(</span><a href="#Eq"><span class="ctor">Eq</span></a> <span class="ident">a</span><span class="syntax">) &lt;=</span> <a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">compare</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <a href="#Ordering"><span class="ctor">Ordering</span></a></code></li></ul><p>The <code>Ord</code> type class represents types which support comparisons.</p>
<p><code>Ord</code> instances should satisfy the laws of <em>partially orderings</em>:</p>
<ul>
<li>Reflexivity: <code>a &lt;= a</code></li>
<li>Antisymmetry: if <code>a &lt;= b</code> and <code>b &lt;= a</code> then <code>a = b</code></li>
<li>Transitivity: if <code>a &lt;= b</code> and <code>b &lt;= c</code> then <code>a &lt;= c</code></li>
</ul>
<a name="(&lt;)" href="#(&lt;)"><h2><code>(&lt;)</code></h2></a><p class="decl"><code><span class="ident">(&lt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></p><ul></ul><p>Test whether one value is <em>strictly less than</em> another.</p>
<a name="(&gt;)" href="#(&gt;)"><h2><code>(&gt;)</code></h2></a><p class="decl"><code><span class="ident">(&gt;)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></p><ul></ul><p>Test whether one value is <em>strictly greater than</em> another.</p>
<a name="(&lt;=)" href="#(&lt;=)"><h2><code>(&lt;=)</code></h2></a><p class="decl"><code><span class="ident">(&lt;=)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></p><ul></ul><p>Test whether one value is <em>non-strictly less than</em> another.</p>
<a name="(&gt;=)" href="#(&gt;=)"><h2><code>(&gt;=)</code></h2></a><p class="decl"><code><span class="ident">(&gt;=)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">a</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ctor">Boolean</span></code></p><ul></ul><p>Test whether one value is <em>non-strictly greater than</em> another.</p>
<a name="ordUnit" href="#ordUnit"><h2><code>ordUnit</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ordUnit</span> <span class="syntax">::</span> <a href="#Ord"><span class="ctor">Ord</span></a> <a href="#Unit"><span class="ctor">Unit</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="ordBoolean" href="#ordBoolean"><h2><code>ordBoolean</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ordBoolean</span> <span class="syntax">::</span> <a href="#Ord"><span class="ctor">Ord</span></a> <span class="ctor">Boolean</span> <span class="keyword">where</span></code></p><ul></ul><a name="ordNumber" href="#ordNumber"><h2><code>ordNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ordNumber</span> <span class="syntax">::</span> <a href="#Ord"><span class="ctor">Ord</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="ordString" href="#ordString"><h2><code>ordString</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ordString</span> <span class="syntax">::</span> <a href="#Ord"><span class="ctor">Ord</span></a> <span class="ctor">String</span> <span class="keyword">where</span></code></p><ul></ul><a name="ordArray" href="#ordArray"><h2><code>ordArray</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">ordArray</span> <span class="syntax">::</span> <span class="syntax">(</span><a href="#Ord"><span class="ctor">Ord</span></a> <span class="ident">a</span><span class="syntax">) =&gt;</span> <a href="#Ord"><span class="ctor">Ord</span></a> <span class="syntax">[</span><span class="ident">a</span><span class="syntax">]</span> <span class="keyword">where</span></code></p><ul></ul><a name="Bits" href="#Bits"><h2><code>Bits</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Bits"><span class="ctor">Bits</span></a> <span class="ident">b</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(.&amp;.)</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">(.|.)</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">(.^.)</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">shl</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ctor">Number</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">shr</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ctor">Number</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">zshr</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ctor">Number</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">complement</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li></ul><p>The <code>Bits</code> type class identifies types which support bitwise operations.</p>
<a name="bitsNumber" href="#bitsNumber"><h2><code>bitsNumber</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">bitsNumber</span> <span class="syntax">::</span> <a href="#Bits"><span class="ctor">Bits</span></a> <span class="ctor">Number</span> <span class="keyword">where</span></code></p><ul></ul><a name="BoolLike" href="#BoolLike"><h2><code>BoolLike</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#BoolLike"><span class="ctor">BoolLike</span></a> <span class="ident">b</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&amp;&amp;)</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">(||)</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li><li><code><span class="ident">not</span> <span class="syntax">::</span> <span class="ident">b</span> <span class="syntax">-&gt;</span> <span class="ident">b</span></code></li></ul><p>The <code>BoolLike</code> type class identifies types which support Boolean operations.</p>
<p><code>BoolLike</code> instances are required to satisfy the laws of a <em>Boolean algebra</em>.</p>
<a name="boolLikeBoolean" href="#boolLikeBoolean"><h2><code>boolLikeBoolean</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">boolLikeBoolean</span> <span class="syntax">::</span> <a href="#BoolLike"><span class="ctor">BoolLike</span></a> <span class="ctor">Boolean</span> <span class="keyword">where</span></code></p><ul></ul><a name="Semigroup" href="#Semigroup"><h2><code>Semigroup</code></h2></a><p class="decl"><code><span class="keyword">class</span> <a href="#Semigroup"><span class="ctor">Semigroup</span></a> <span class="ident">a</span> <span class="keyword">where</span></code></p><ul><li><code><span class="ident">(&lt;&gt;)</span> <span class="syntax">::</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span> <span class="syntax">-&gt;</span> <span class="ident">a</span></code></li></ul><p>The <code>Semigroup</code> type class identifies an associative operation on a type.</p>
<p><code>Semigroup</code> instances are required to satisfy the following law:</p>
<ul>
<li>Associativity: <code>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</code></li>
</ul>
<p>For example, the <code>String</code> type is an instance of <code>Semigroup</code>, where <code>(&lt;&gt;)</code> is defined to be string concatenation.</p>
<a name="semigroupUnit" href="#semigroupUnit"><h2><code>semigroupUnit</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semigroupUnit</span> <span class="syntax">::</span> <a href="#Semigroup"><span class="ctor">Semigroup</span></a> <a href="#Unit"><span class="ctor">Unit</span></a> <span class="keyword">where</span></code></p><ul></ul><a name="semigroupString" href="#semigroupString"><h2><code>semigroupString</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semigroupString</span> <span class="syntax">::</span> <a href="#Semigroup"><span class="ctor">Semigroup</span></a> <span class="ctor">String</span> <span class="keyword">where</span></code></p><ul></ul><a name="semigroupArr" href="#semigroupArr"><h2><code>semigroupArr</code></h2></a><p class="decl"><code><span class="keyword">instance</span> <span class="ident">semigroupArr</span> <span class="syntax">::</span> <span class="syntax">(</span><a href="#Semigroup"><span class="ctor">Semigroup</span></a> <span class="ident">s&#39;</span><span class="syntax">) =&gt;</span> <a href="#Semigroup"><span class="ctor">Semigroup</span></a> <span class="syntax">(</span><span class="ident">s</span> <span class="syntax">-&gt;</span> <span class="ident">s&#39;</span><span class="syntax">)</span> <span class="keyword">where</span></code></p><ul></ul><a name="(++)" href="#(++)"><h2><code>(++)</code></h2></a><p class="decl"><code><span class="ident">(++)</span> <span class="syntax">::</span> <span class="keyword">forall</span> <span class="ident">s</span><span class="syntax">.</span> <span class="syntax">(</span><a href="#Semigroup"><span class="ctor">Semigroup</span></a> <span class="ident">s</span><span class="syntax">)</span> <span class="syntax">=&gt;</span> <span class="ident">s</span> <span class="syntax">-&gt;</span> <span class="ident">s</span> <span class="syntax">-&gt;</span> <span class="ident">s</span></code></p><ul></ul><p><code>(++)</code> is an alias for <code>(&lt;&gt;)</code>.</p>
</div></body></html>