{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Applicative
import Control.Monad
import Control.Monad.Writer
import Control.Arrow (first)
import Data.Function (on)
import Data.Default (def)
import Data.List (nub)
import Data.String (fromString)
import Data.Maybe (fromMaybe)
import Data.Version (showVersion)
import Data.Foldable (traverse_, for_)

import qualified Data.Text.Lazy as T
import qualified Data.Text.Lazy.IO as T

import Options.Applicative

import qualified Language.PureScript as P
import qualified Paths_psc_pages as Paths

import System.Exit (exitSuccess, exitFailure)
import System.IO (hPutStrLn, stderr)
import System.FilePath ((</>), takeDirectory, makeRelative)
import System.Directory (createDirectoryIfMissing)

import Text.Blaze.Html ((!))
import qualified Text.Blaze.Html as H
import qualified Text.Blaze.Html.Renderer.Text as H
import qualified Text.Blaze.Html5 as H
import qualified Text.Blaze.Html5.Attributes as A

import qualified Cheapskate

app :: ([FilePath], FilePath) -> IO ()
app (input, outputDir) = do
  e <- P.parseModulesFromFiles (fromMaybe "") <$> mapM (fmap (first Just) . parseFile) (nub input)
  case e of
    Left err -> do
      hPutStrLn stderr $ show err
      exitFailure
    Right ms -> do
      T.writeFile (outputDir </> "style.css") stylesheet
      for_ (map snd ms) (renderModule outputDir)
      exitSuccess
  where
  parseFile :: FilePath -> IO (FilePath, String)
  parseFile input = (,) input <$> readFile input

renderModule :: FilePath -> P.Module -> IO ()
renderModule outputDir m@(P.Module moduleName _ exps) = do
  let filename = outputDir </> filePathFor moduleName
      html = H.renderHtml $ moduleToHtml outputDir m
  mkdirp filename
  T.writeFile filename html
  where
  mkdirp = createDirectoryIfMissing True . takeDirectory

stylesheet :: T.Text
stylesheet = 
  "body {\
  \  font-family: sans-serif;\
  \}\
  \.decl {\
  \  background-color: lightgray;\
  \  padding: 2px;\
  \}\
  \.keyword {\
  \  font-weight: body;\
  \}\
  \.ident {\
  \  color: blue;\
  \}\
  \.syntax {\
  \  color: gray;\
  \}\
  \#header, #footer {\
  \  background-color: lightblue;\
  \  padding: 5px;\
  \}\
  \h1, h2, h3, h4, h5, h6 {\
  \  margin: 0;\
  \}\
  \.typeclass {\
  \  margin-left: 10px;\
  \}"

filePathFor :: P.ModuleName -> FilePath
filePathFor (P.ModuleName parts) = go parts
  where
  go [] = "index.html"
  go (x : xs) = show x </> go xs

text :: String -> H.Html
text = H.toHtml

sp :: H.Html
sp = text " "

withClass :: H.AttributeValue -> H.Html -> H.Html
withClass className content = H.span ! A.class_ className $ content

para :: H.AttributeValue -> H.Html -> H.Html
para className content = H.p ! A.class_ className $ content

intercalateA_ :: (Applicative m) => m b -> [m a] -> m ()
intercalateA_ _   []     = pure ()
intercalateA_ _   [x]    = void x
intercalateA_ sep (x:xs) = (x <* sep) *> intercalateA_ sep xs

moduleToHtml :: FilePath -> P.Module -> H.Html
moduleToHtml outputDir (P.Module moduleName ds exps) = do
  H.docType
  H.html $ do
    H.head $ do
      H.link ! A.rel "stylesheet" ! A.type_ "text/css" ! A.href (fromString (filePathFor moduleName `makeRelative` (outputDir </> "style.css")))
      H.title $ H.toHtml $ show moduleName
    H.body $ do
      H.div ! A.id "header" $ do
        H.h1 $ H.toHtml $ show moduleName
      for_ ds (declToHtml exps)
      H.div ! A.id "footer" $ 
        H.small $ H.toHtml $ "Generated by psc-pages " ++ showVersion Paths.version

declToHtml :: Maybe [P.DeclarationRef] -> P.Declaration -> H.Html
declToHtml exps decl = do
  for_ (getDeclarationTitle decl) $ \s -> 
    H.a ! A.name (fromString s) $ mempty
  renderDeclaration exps decl

getDeclarationTitle :: P.Declaration -> Maybe String
getDeclarationTitle (P.TypeDeclaration name _)                      = Just (show name)
getDeclarationTitle (P.ExternDeclaration _ name _ _)                = Just (show name)
getDeclarationTitle (P.DataDeclaration _ name _ _)                  = Just (show name)
getDeclarationTitle (P.ExternDataDeclaration name _)                = Just (show name)
getDeclarationTitle (P.TypeSynonymDeclaration name _ _)             = Just (show name)
getDeclarationTitle (P.TypeClassDeclaration name _ _ _)   = Just (show name)
getDeclarationTitle (P.TypeInstanceDeclaration name _ _ _ _)        = Just (show name)
getDeclarationTitle (P.PositionedDeclaration _ _ d)                 = getDeclarationTitle d
getDeclarationTitle _                                               = Nothing

renderDeclaration :: Maybe [P.DeclarationRef] -> P.Declaration -> H.Html
renderDeclaration _ (P.TypeDeclaration ident ty) =
  para "decl" $ H.code $ do
    withClass "ident" . text . show $ ident
    sp *> withClass "syntax" (text "::") <* sp
    typeToHtml ty
renderDeclaration _ (P.ExternDeclaration _ ident _ ty) =
  para "decl" $ H.code $ do
    withClass "ident" . text . show $ ident
    sp *> withClass "syntax" (text "::") <* sp
    typeToHtml ty
renderDeclaration exps (P.DataDeclaration dtype name args ctors) = do
  let typeApp  = foldl P.TypeApp (P.TypeConstructor (P.Qualified Nothing name)) (map toTypeVar args)
      exported = filter (P.isDctorExported name exps . fst) ctors
  para "decl" $ H.code $ do
    withClass "keyword" . text $ show dtype  
    sp
    typeToHtml typeApp
  H.h3 $ text "Constructors"
  H.ul $ for_ exported $ \(ctor, tys) -> H.li . H.code $ do
    withClass "ctor" . text $ P.runProperName ctor
    for_ tys $ \ty -> sp *> typeToHtml ty
renderDeclaration _ (P.ExternDataDeclaration name kind) = do
  para "decl" $ H.code $ do
    withClass "keyword" . text $ "data"  
    sp
    typeToHtml $ P.TypeConstructor (P.Qualified Nothing name)
    withClass "syntax" " :: "
    text $ P.prettyPrintKind kind
renderDeclaration _ (P.TypeSynonymDeclaration name args ty) = do
  let typeApp  = foldl P.TypeApp (P.TypeConstructor (P.Qualified Nothing name)) (map toTypeVar args)
  para "decl" $ H.code $ do
    withClass "keyword" . text $ "type" 
    sp
    typeToHtml typeApp
    withClass "syntax" " = "
    typeToHtml ty
renderDeclaration _ (P.TypeClassDeclaration name args implies ds) = do
  para "decl" $ H.code $ do
    withClass "syntax" (text "class") <* sp
    case implies of
      [] -> ""
      _ -> do withClass "syntax" $ text "("
              intercalateA_ (withClass "syntax" "," <* sp) $ flip map implies $ \(pn, tys') -> do
                let supApp = foldl P.TypeApp (P.TypeConstructor pn) tys'
                typeToHtml supApp
              withClass "syntax" $ text ") <= "
    let classApp  = foldl P.TypeApp (P.TypeConstructor (P.Qualified Nothing name)) (map toTypeVar args)
    typeToHtml classApp
  H.h3 $ text "Type Class Members"
  H.div ! A.class_ "typeclass" $ mapM_ renderClassMember ds
  where
  renderClassMember :: P.Declaration -> H.Html
  renderClassMember (P.PositionedDeclaration _ _ d) = renderClassMember d
  renderClassMember (P.TypeDeclaration ident ty) =
    para "decl" $ H.code $ do
      withClass "ident" . text . show $ ident
      sp *> withClass "syntax" (text "::") <* sp
      typeToHtml ty
  renderClassMember _ = error "Invalid argument to renderClassMember."
renderDeclaration _ (P.TypeInstanceDeclaration name constraints className tys _) = do
  para "decl" $ H.code $ do
    withClass "syntax" (text "instance") <* sp
    withClass "ident" (text (show name)) <* sp
    withClass "syntax" (text "::") <* sp
    case constraints of
      [] -> ""
      _ -> do withClass "syntax" $ text "("
              intercalateA_ (withClass "syntax" "," <* sp) $ flip map constraints $ \(pn, tys') -> do
                let supApp = foldl P.TypeApp (P.TypeConstructor pn) tys'
                typeToHtml supApp
              withClass "syntax" $ text ") => "
    let classApp = foldl P.TypeApp (P.TypeConstructor className) tys
    typeToHtml classApp
renderDeclaration exps (P.PositionedDeclaration _ com d) = do
  renderDeclaration exps d
  renderComments com
renderDeclaration _ _ = return ()

renderComments :: [P.Comment] -> H.Html
renderComments cs = do
  let raw = concatMap toLines cs
  
  if all hasPipe raw
    then H.toHtml . Cheapskate.markdown def . fromString . unlines . map stripPipes $ raw
    else H.pre . H.code . H.toHtml $ unlines raw
  where

  toLines (P.LineComment s) = [s]
  toLines (P.BlockComment s) = lines s
  
  hasPipe s = case dropWhile (== ' ') s of { ('|':_) -> True; _ -> False }
  
  stripPipes = dropPipe . dropWhile (== ' ')

  dropPipe ('|':' ':s) = s
  dropPipe ('|':s) = s
  dropPipe s = s

toTypeVar :: (String, Maybe P.Kind) -> P.Type
toTypeVar (s, Nothing) = P.TypeVar s
toTypeVar (s, Just k) = P.KindedType (P.TypeVar s) k

-- | TODO: improve this
typeToHtml :: P.Type -> H.Html
typeToHtml = H.toHtml . P.prettyPrintType . P.everywhereOnTypes dePrim
  where
  dePrim ty@(P.TypeConstructor (P.Qualified _ name))
    | ty == P.tyBoolean || ty == P.tyNumber || ty == P.tyString =
      P.TypeConstructor $ P.Qualified Nothing name
  dePrim other = other

inputFiles :: Parser [FilePath]
inputFiles = many . strArgument $
     metavar "FILE"
  <> help "The input .purs file(s)"
  
outputDirectory :: Parser FilePath
outputDirectory = strOption $
     short 'o'
  <> long "output"
  <> help "The output .js file"

main :: IO ()
main = execParser opts >>= app
  where
  opts        = info (helper <*> ((,) <$> inputFiles <*> outputDirectory)) infoModList
  infoModList = fullDesc <> headerInfo <> footerInfo
  headerInfo  = header   "psc-pages - Generate HTML documentation from PureScript source files"
  footerInfo  = footer $ "psc-pages " ++ showVersion Paths.version
